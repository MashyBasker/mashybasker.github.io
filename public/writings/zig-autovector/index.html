<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Triggering Auto-Vectorization in Zig Standard Library method | basum</title>
<meta name="keywords" content="zig, llvm, simd">
<meta name="description" content="An exploration of how LLVM’s auto-vectorization can be used to optimize Zig’s std.mem.allEqual, and the surprising performance implications that follow.">
<meta name="author" content="Maharshi Basu">
<link rel="canonical" href="http://localhost:1313/writings/zig-autovector/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/writings/zig-autovector/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


<meta property="og:url" content="http://localhost:1313/writings/zig-autovector/">
  <meta property="og:site_name" content="basum">
  <meta property="og:title" content="Triggering Auto-Vectorization in Zig Standard Library method">
  <meta property="og:description" content="An exploration of how LLVM’s auto-vectorization can be used to optimize Zig’s std.mem.allEqual, and the surprising performance implications that follow.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="writings">
    <meta property="article:published_time" content="2025-06-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-08T00:00:00+00:00">
    <meta property="article:tag" content="Zig">
    <meta property="article:tag" content="Llvm">
    <meta property="article:tag" content="Simd">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Triggering Auto-Vectorization in Zig Standard Library method">
<meta name="twitter:description" content="An exploration of how LLVM’s auto-vectorization can be used to optimize Zig’s std.mem.allEqual, and the surprising performance implications that follow.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Writings",
      "item": "http://localhost:1313/writings/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Triggering Auto-Vectorization in Zig Standard Library method",
      "item": "http://localhost:1313/writings/zig-autovector/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Triggering Auto-Vectorization in Zig Standard Library method",
  "name": "Triggering Auto-Vectorization in Zig Standard Library method",
  "description": "An exploration of how LLVM’s auto-vectorization can be used to optimize Zig’s std.mem.allEqual, and the surprising performance implications that follow.",
  "keywords": [
    "zig", "llvm", "simd"
  ],
  "articleBody": "Introduction I read this post recently by Nikita Sivukhin. In it, they refactor a find method to locate the position of an element in a slice. The optimization takes advantage of LLVM’s auto-vectorization to improve performance.\nI decided to apply the techniques discussed to the std.mem.allEqual function in Zig’s standard library to investigate how vectorization could affect its performance.\nThe Standard Library The allEqual method is defined as\nReturns true if all elements in a slice are equal to the scalar value provided\nWith this pretty simple source code:\npub fn allEqual(comptime T: type, slice: []const T, scalar: T) bool { for (slice) |item| { if (item != scalar) return false; } return true; } Putting this on godbolt using Zig 0.14.1 and the flags -O ReleaseFast -target x86_64-linux -mcpu=native gives the compiler output:\nallEqual: push rbp mov rbp, rsp test rsi, rsi je .LBB0_1 cmp dword ptr [rdi], edx jne .LBB0_3 mov ecx, 1 .LBB0_7: mov rax, rcx cmp rsi, rcx je .LBB0_4 lea rcx, [rax + 1] cmp dword ptr [rdi + 4*rax], edx je .LBB0_7 .LBB0_4: cmp rax, rsi setae al pop rbp ret .LBB0_1: mov al, 1 pop rbp ret .LBB0_3: xor eax, eax pop rbp ret However, this approach lacks vectorization. Why doesn’t LLVM apply it? To understand what might be preventing vectorization, we can check the LLVM optimization remarks for clues.\nUnlike Rust, Zig doesn’t support passing arbitrary LLVM flags such as -pass-remarks, -pass-remarks-missed, or -pass-remarks-analysis directly. To work around this, we need to first emit the LLVM IR using the -emit-llvm-ir flag to generate a .ll file. Then use the llvm-opt tool on this file to generate the optimization remarks.\nSetting up the development environment I used Nix with Devenv to set up the environment. Just run devenv init in your project directory and configure the devenv.nix file as needed:\n{ pkgs, lib, config, inputs, ... }: { languages.zig.enable = true; packages = with pkgs; [ llvmPackages_19.llvm ]; } Finally execute devenv shell to build the environment.\nInvestigation We put the following slightly modified code in a test.zig file.\nconst std = @import(\"std\"); export fn allEqual_std(data: [*]const u8, len: usize, target: u8) bool { return std.mem.allEqual(u8, data[0..len], target); } The export keyword is needed, otherwise LLVM’s dead code elimination will ignore this function as its never actually called.\nExecuting:\nzig build-obj -femit-llvm-ir=test.ll -femit-asm=output.s -O ReleaseFast test.zig \u0026\u0026 opt -O3 \\ -pass-remarks=.* \\ -pass-remarks-missed=.* \\ -pass-remarks-analysis=.* \\ test.ll -S -o optimized.ll The following output is received:\nremarks-analysis=.* test.ll -S -o optimized.ll remark: mem.zig:1191:10: loop not vectorized: could not determine number of loop iterations remark: mem.zig:1191:10: loop not vectorized The remark loop not vectorized: could not determine number of loop iterations means the compiler can’t statically determine how many times the loop will run. Vectorization needs predictable iteration counts to safely group operations into SIMD instructions, which is handled by the LoopVectorizer.\nThis can be caused by non-constant loop bounds or early exits. In the original implementation of std.mem.allEqual in the standard library, there’s an early return statement inside the loop. That’s what prevents the loop from being vectorized.\nRefactor and Restructure To trigger loop vectorization, the implementation must be modified to not use early returns:\nexport fn allEqual_no_early_stop(slice: [*]const u8, len: usize, scalar: u8) bool { var m: bool = true; for (slice[0..len]) |item| { m = m and (item == scalar); } return m; } This looks correct, now let’s check the compiler output and the LLVM remarks.\n.LBB0_5: cmp byte ptr [rdi + r8], dl sete r9b and r9b, al cmp byte ptr [rdi + r8 + 1], dl sete al cmp byte ptr [rdi + r8 + 2], dl sete r10b and r10b, al and r10b, r9b cmp byte ptr [rdi + r8 + 3], dl sete al cmp byte ptr [rdi + r8 + 4], dl sete r9b and r9b, al ... Unfortunately, there still isn’t any SIMD output. However, the loop does get unrolled, and the compiler generates branchless code with no jump instructions. The following remarks are generated:\nremark: w.zig:11:15: loop not vectorized: value that could not be identified as reduction is used outside the loop remark: w.zig:11:15: loop not vectorized remark: w.zig:11:15: loop not vectorized: value that could not be identified as reduction is used outside the loop remark: w.zig:11:15: loop not vectorized remark: :0:0: Cannot SLP vectorize list: vectorization was impossible with available vectorization factors remark: w.zig:12:9: Vectorized horizontal reduction with cost -17 and with tree size 3 remark: w.zig:11:15: unrolled loop by a factor of 8 with run-time trip count That’s a lot. What do they mean?\nThe good news\nVectorized horizontal reduction with cost -17 and with tree size 3\nThis refers to a SIMD operation that reduces vector elements into a single scalar value. The -17 indicates a profitable optimization according to LLVM’s vectorization cost model. A tree size of 3 reflects the structure of the operation’s dependency graph and 3 is its depth.\nunrolled loop by a factor of 8 with run-time trip count\nThis means the LLVM optimizer has applied runtime loop unrolling with an unroll factor of 8 i.e. each iteration of the unrolled loop performs the work of 8 iterations of the original loop.\nThe bad news\nloop not vectorized: value that could not be identified as reduction is used outside the loop\nThis remark is due to something known as Data Dependency Chain. It prevents the compiler from generating vectorized output from the above implementation. I’ll get to it soon.\nCannot SLP vectorize list: vectorization was impossible with available vectorization factors\nThe SLPVectorizer combines similar independent instructions into vector instructions. This could not be achieved here due to the reduction pattern in the code m = m and (item == scalar) as well as the dependency chain.\nData Dependency Chain In the current implementation there is:\nm = m and (item == scalar); This is a read-after-write dependency. It is not vectorizable because each iteration depends on the previous value of m. Iteration $N +1$ cannot be computed until the result of iteration $N$ is known.\nA method is needed to check whether all elements of a slice are equal to a given scalar, without introducing data dependencies, and where the result of each iteration is independent of the others.\nThe following is a well-known vectorizable pattern that uses summation:\nexport fn allEqual_no_early_stop(slice: [*]const u8, len: usize, scalar: u8) bool { var mismatch_count: u32 = 0; for (slice[0..len]) |item| { mismatch_count += @intFromBool(item != scalar); } return mismatch_count == 0; } Here we count the number of mismatches and equate it with zero. If all the elements of the slice are equal to the scalar. The result of the operation @intFromBool(item != scalar) is independent of the other results of the other iterations. So, it is safe to vectorize. Looking at the compiler output:\n.LBB0_6: vmovq xmm7, qword ptr [rdi + rcx] vmovq xmm8, qword ptr [rdi + rcx + 8] vmovq xmm9, qword ptr [rdi + rcx + 16] vmovq xmm10, qword ptr [rdi + rcx + 24] vpcmpeqb xmm7, xmm7, xmm1 vpxor xmm7, xmm7, xmm2 vpmovzxbd ymm7, xmm7 vpand ymm7, ymm7, ymm3 vpaddd ymm0, ymm0, ymm7 vpcmpeqb xmm7, xmm8, xmm1 vpxor xmm7, xmm7, xmm2 vpmovzxbd ymm7, xmm7 vpand ymm7, ymm7, ymm3 vpaddd ymm4, ymm4, ymm7 vpcmpeqb xmm7, xmm9, xmm1 ... We can see the SSE registers, and hence LLVM is successfully able to vectorize the allEqual function.\nWe get the following remarks:\nremark: w.zig:4:15: loop not vectorized: vectorization and interleaving are explicitly disabled, or the loop has already been vectorized remark: w.zig:4:15: loop not vectorized: vectorization and interleaving are explicitly disabled, or the loop has already been vectorized This remark can occur due to two reasons:\nVectorization has been explicitly disabled using compiler flags such as -fno-vectorize or -fno-unroll-loops.\nThe loops were already vectorized in an earlier optimization phase, so llvm-opt skips redundant attempts.\nSince we did not use any such disabling flags, the remark likely results from the second reason. Indicating that the loops have already been successfully vectorized.\nResults Benchmarking the stdlib implementation against the new implementation that triggers LLVM’s auto-vectorizer. The benchmark is performed against 3 scenarios:\nAll elements of the slice match the target. Only the first element does not match the target. Only the last element does not match the target. 1. All elements equal to the target\nMethod Median (ns) Mean(ns) Throughput std.mem.allEqual 581131 580878 7e9 allEqual_no_early 192468 192378 2e10 2. Only the first element does not match the target.\nMethod Median(ns) Min(ns) Throughput std.mem.allEqual 0 0 inf allEqual_no_early 194103 196067 2e10 3. Only the last element does not match the target\nMethod Median(ns) Min(ns) Throughput std.mem.allEqual 557238 557433 7e9 allEqual_no_early 194800 194474 2e10 Conclusion The auto-vectorized implementation performs well only when all elements match the scalar value or the first mismatch is near the end. If there’s a mismatch early on, the early-stopping version is faster. It returns as soon as a mismatch is found, while the vectorized version still scans the entire slice to count all mismatches.\nReferences Auto-Vectorization in LLVM Cornell Virtual Workshop - Data Dependencies Find element’s position in Rust – 9 times faster! - Nikita Sivukhin ",
  "wordCount" : "1521",
  "inLanguage": "en",
  "datePublished": "2025-06-08T00:00:00Z",
  "dateModified": "2025-06-08T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Maharshi Basu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/writings/zig-autovector/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "basum",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="basum (Alt + H)">basum</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/writings" title="Writings">
                    <span>Writings</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/resume.pdf" title="CV">
                    <span>CV</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/writings/">Writings</a></div>
    <h1 class="post-title entry-hint-parent">
      Triggering Auto-Vectorization in Zig Standard Library method
    </h1>
    <div class="post-description">
      An exploration of how LLVM’s auto-vectorization can be used to optimize Zig’s std.mem.allEqual, and the surprising performance implications that follow.
    </div>
    <div class="post-meta"><span title='2025-06-08 00:00:00 +0000 UTC'>June 8, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Maharshi Basu

</div>
  </header> 
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>I read <a href="https://sivukhin.github.io/find-slice-element-position-in-rust.html">this post</a> recently by Nikita Sivukhin. In it, they refactor a <code>find</code> method to locate the position of an element in a slice. The optimization takes advantage of LLVM’s auto-vectorization to improve performance.</p>
<p>I decided to apply the techniques discussed to the <code>std.mem.allEqual</code> function in Zig’s standard library to investigate how vectorization could affect its performance.</p>
<h2 id="the-standard-library">The Standard Library<a hidden class="anchor" aria-hidden="true" href="#the-standard-library">#</a></h2>
<p>The <code>allEqual</code> method is defined as</p>
<blockquote>
<p>Returns true if all elements in a slice are equal to the scalar value provided</p></blockquote>
<p>With this pretty simple source code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">allEqual</span>(<span style="color:#66d9ef">comptime</span> T<span style="color:#f92672">:</span> <span style="color:#66d9ef">type</span>, slice<span style="color:#f92672">:</span> []<span style="color:#66d9ef">const</span> T, scalar<span style="color:#f92672">:</span> T) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (slice) <span style="color:#f92672">|</span>item<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (item <span style="color:#f92672">!=</span> scalar) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Putting this on <a href="https://godbolt.org/z/zqczGb13e">godbolt</a> using Zig 0.14.1 and the flags <code>-O ReleaseFast -target x86_64-linux -mcpu=native</code> gives the compiler output:</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>allEqual:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">push</span>    <span style="color:#66d9ef">rbp</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rbp</span>, <span style="color:#66d9ef">rsp</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">test</span>    <span style="color:#66d9ef">rsi</span>, <span style="color:#66d9ef">rsi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">je</span>      <span style="color:#66d9ef">.LBB0_1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">dword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span>], <span style="color:#66d9ef">edx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">jne</span>     <span style="color:#66d9ef">.LBB0_3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>.LBB0_7:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">rcx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">rsi</span>, <span style="color:#66d9ef">rcx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">je</span>      <span style="color:#66d9ef">.LBB0_4</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lea</span>     <span style="color:#66d9ef">rcx</span>, [<span style="color:#66d9ef">rax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">dword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">4</span>*<span style="color:#66d9ef">rax</span>], <span style="color:#66d9ef">edx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">je</span>      <span style="color:#66d9ef">.LBB0_7</span>
</span></span><span style="display:flex;"><span>.LBB0_4:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">rsi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setae</span>   <span style="color:#66d9ef">al</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pop</span>     <span style="color:#66d9ef">rbp</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>.LBB0_1:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span>     <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pop</span>     <span style="color:#66d9ef">rbp</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>.LBB0_3:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">xor</span>     <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pop</span>     <span style="color:#66d9ef">rbp</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted -->
However, this approach lacks vectorization. Why doesn’t LLVM apply it? To understand what might be preventing vectorization, we can check the <a href="https://llvm.org/docs/Remarks.html">LLVM optimization remarks</a> for clues.</p>
<p>Unlike Rust, Zig doesn&rsquo;t support passing arbitrary LLVM flags such as <code>-pass-remarks</code>, <code>-pass-remarks-missed</code>, or <code>-pass-remarks-analysis</code> directly. To work around this, we need to first emit the LLVM IR using the <code>-emit-llvm-ir</code> flag to generate a <code>.ll</code> file. Then use the <a href="https://llvm.org/docs/CommandGuide/opt.html"><code>llvm-opt</code></a> tool on this file to generate the optimization remarks.</p>
<h3 id="setting-up-the-development-environment">Setting up the development environment<a hidden class="anchor" aria-hidden="true" href="#setting-up-the-development-environment">#</a></h3>
<p>I used <a href="https://nix.dev/">Nix</a> with <a href="https://devenv.sh/">Devenv</a> to set up the environment. Just run <code>devenv init</code> in your project directory and configure the <code>devenv.nix</code> file as needed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>{ pkgs<span style="color:#f92672">,</span> lib<span style="color:#f92672">,</span> config<span style="color:#f92672">,</span> inputs<span style="color:#f92672">,</span> <span style="color:#f92672">...</span> }:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  languages<span style="color:#f92672">.</span>zig<span style="color:#f92672">.</span>enable <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  packages <span style="color:#f92672">=</span> <span style="color:#66d9ef">with</span> pkgs; [
</span></span><span style="display:flex;"><span>        llvmPackages_19<span style="color:#f92672">.</span>llvm
</span></span><span style="display:flex;"><span>  ];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally execute <code>devenv shell</code> to build the environment.</p>
<h3 id="investigation">Investigation<a hidden class="anchor" aria-hidden="true" href="#investigation">#</a></h3>
<p>We put the following slightly modified code in a <code>test.zig</code> file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">allEqual_std</span>(data<span style="color:#f92672">:</span> [<span style="color:#f92672">*</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>, len<span style="color:#f92672">:</span> <span style="color:#66d9ef">usize</span>, target<span style="color:#f92672">:</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std.mem.<span style="color:#a6e22e">allEqual</span>(<span style="color:#66d9ef">u8</span>, data[<span style="color:#ae81ff">0</span>..len], target);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>export</code> keyword is needed, otherwise LLVM&rsquo;s dead code elimination will ignore this function as its never actually called.</p>
<p>Executing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>zig build-obj -femit-llvm-ir<span style="color:#f92672">=</span>test.ll -femit-asm<span style="color:#f92672">=</span>output.s -O ReleaseFast test.zig <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>opt -O3 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -pass-remarks<span style="color:#f92672">=</span>.* <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -pass-remarks-missed<span style="color:#f92672">=</span>.* <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -pass-remarks-analysis<span style="color:#f92672">=</span>.* <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  test.ll -S -o optimized.ll
</span></span></code></pre></div><p>The following output is received:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>remarks-analysis<span style="color:#f92672">=</span>.*   test.ll -S -o optimized.ll
</span></span><span style="display:flex;"><span>remark: mem.zig:1191:10: loop not vectorized: could not determine number of loop iterations
</span></span><span style="display:flex;"><span>remark: mem.zig:1191:10: loop not vectorized
</span></span></code></pre></div><p>The remark <code>loop not vectorized: could not determine number of loop iterations</code> means the compiler can&rsquo;t statically determine how many times the loop will run. Vectorization needs predictable iteration counts to safely group operations into SIMD instructions, which is handled by the <a href="https://llvm.org/docs/Vectorizers.html#loop-vectorizer">LoopVectorizer</a>.</p>
<p>This can be caused by non-constant loop bounds or early exits. In the original implementation of <code>std.mem.allEqual</code> in the standard library, there’s an early <code>return</code> statement inside the loop. That’s what prevents the loop from being vectorized.</p>
<h3 id="refactor-and-restructure">Refactor and Restructure<a hidden class="anchor" aria-hidden="true" href="#refactor-and-restructure">#</a></h3>
<p>To trigger loop vectorization, the implementation must be modified to not use early returns:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">allEqual_no_early_stop</span>(slice<span style="color:#f92672">:</span> [<span style="color:#f92672">*</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>, len<span style="color:#f92672">:</span> <span style="color:#66d9ef">usize</span>, scalar<span style="color:#f92672">:</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> m<span style="color:#f92672">:</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (slice[<span style="color:#ae81ff">0</span>..len]) <span style="color:#f92672">|</span>item<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> m <span style="color:#66d9ef">and</span> (item <span style="color:#f92672">==</span> scalar);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> m;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This looks correct, now let&rsquo;s check the compiler output and the LLVM remarks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>.LBB0_5:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">r8</span>], <span style="color:#66d9ef">dl</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sete</span>    <span style="color:#66d9ef">r9b</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">and</span>     <span style="color:#66d9ef">r9b</span>, <span style="color:#66d9ef">al</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">r8</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">1</span>], <span style="color:#66d9ef">dl</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sete</span>    <span style="color:#66d9ef">al</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">r8</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">dl</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sete</span>    <span style="color:#66d9ef">r10b</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">and</span>     <span style="color:#66d9ef">r10b</span>, <span style="color:#66d9ef">al</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">and</span>     <span style="color:#66d9ef">r10b</span>, <span style="color:#66d9ef">r9b</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">r8</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">3</span>], <span style="color:#66d9ef">dl</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sete</span>    <span style="color:#66d9ef">al</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmp</span>     <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">r8</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">4</span>], <span style="color:#66d9ef">dl</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sete</span>    <span style="color:#66d9ef">r9b</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">and</span>     <span style="color:#66d9ef">r9b</span>, <span style="color:#66d9ef">al</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">...</span>
</span></span></code></pre></div><p>Unfortunately, there still isn&rsquo;t any SIMD <a href="https://godbolt.org/z/7d8bff8fK">output</a>. However, the loop does get unrolled, and the compiler generates branchless code with no jump instructions. The following remarks are generated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>remark: w.zig:11:15: loop not vectorized: value that could not be identified as reduction is used outside the loop
</span></span><span style="display:flex;"><span>remark: w.zig:11:15: loop not vectorized
</span></span><span style="display:flex;"><span>remark: w.zig:11:15: loop not vectorized: value that could not be identified as reduction is used outside the loop
</span></span><span style="display:flex;"><span>remark: w.zig:11:15: loop not vectorized
</span></span><span style="display:flex;"><span>remark: &lt;unknown&gt;:0:0: Cannot SLP vectorize list: vectorization was impossible with available vectorization factors
</span></span><span style="display:flex;"><span>remark: w.zig:12:9: Vectorized horizontal reduction with cost -17 and with tree size <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>remark: w.zig:11:15: unrolled loop by a factor of <span style="color:#ae81ff">8</span> with run-time trip count
</span></span></code></pre></div><p>That&rsquo;s a lot. What do they mean?</p>
<p><em><strong>The good news</strong></em></p>
<blockquote>
<p>Vectorized horizontal reduction with cost -17 and with tree size 3</p></blockquote>
<p>This refers to a SIMD operation that reduces vector elements into a single scalar value. The <code>-17</code> indicates a profitable optimization according to LLVM’s vectorization cost model. A tree size of <code>3</code> reflects the structure of the operation’s dependency graph and <code>3</code> is its depth.</p>
<blockquote>
<p>unrolled loop by a factor of 8 with run-time trip count</p></blockquote>
<p>This means the LLVM optimizer has applied <em>runtime loop unrolling</em> with an unroll factor of 8 i.e. each iteration of the unrolled loop performs the work of 8 iterations of the original loop.</p>
<p><em><strong>The bad news</strong></em></p>
<blockquote>
<p>loop not vectorized: value that could not be identified as reduction is used outside the loop</p></blockquote>
<p>This remark is due to something known as <a href="https://cvw.cac.cornell.edu/vector/coding/data-dependencies">Data Dependency Chain</a>. It prevents the compiler from generating vectorized output from the above implementation. I&rsquo;ll get to it soon.</p>
<blockquote>
<p>Cannot SLP vectorize list: vectorization was impossible with available vectorization factors</p></blockquote>
<p>The <code>SLPVectorizer</code> combines similar independent instructions into vector instructions. This could not be achieved here due to the reduction pattern in the code <code>m = m and (item == scalar)</code>  as well as the dependency chain.</p>
<h3 id="data-dependency-chain">Data Dependency Chain<a hidden class="anchor" aria-hidden="true" href="#data-dependency-chain">#</a></h3>
<p>In the current implementation there is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span>m <span style="color:#f92672">=</span> m <span style="color:#66d9ef">and</span> (item <span style="color:#f92672">==</span> scalar);
</span></span></code></pre></div><p>This is a <em>read-after-write</em> dependency. It is not vectorizable because each iteration depends on the previous value of <code>m</code>. Iteration $N +1$ cannot be computed until the result of iteration $N$ is known.</p>
<p>A method is needed to check whether all elements of a slice are equal to a given scalar, without introducing data dependencies, and where the result of each iteration is independent of the others.</p>
<p>The following is a well-known vectorizable pattern that uses summation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">allEqual_no_early_stop</span>(slice<span style="color:#f92672">:</span> [<span style="color:#f92672">*</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>, len<span style="color:#f92672">:</span> <span style="color:#66d9ef">usize</span>, scalar<span style="color:#f92672">:</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> mismatch_count<span style="color:#f92672">:</span> <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (slice[<span style="color:#ae81ff">0</span>..len]) <span style="color:#f92672">|</span>item<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        mismatch_count <span style="color:#f92672">+=</span> @intFromBool(item <span style="color:#f92672">!=</span> scalar);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mismatch_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we count the number of mismatches and equate it with zero. If all the elements of the slice are equal to the scalar. The result of the operation <code>@intFromBool(item != scalar)</code> is independent of the other results of the other iterations. So, it is safe to vectorize. Looking at the compiler <a href="https://godbolt.org/z/fqGP1xjbz">output</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>.LBB0_6:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovq</span>   <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">qword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">rcx</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovq</span>   <span style="color:#66d9ef">xmm8</span>, <span style="color:#66d9ef">qword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">rcx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovq</span>   <span style="color:#66d9ef">xmm9</span>, <span style="color:#66d9ef">qword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">rcx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">16</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vmovq</span>   <span style="color:#66d9ef">xmm10</span>, <span style="color:#66d9ef">qword</span> <span style="color:#66d9ef">ptr</span> [<span style="color:#66d9ef">rdi</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">rcx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">24</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpcmpeqb</span>        <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpxor</span>   <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpmovzxbd</span>       <span style="color:#66d9ef">ymm7</span>, <span style="color:#66d9ef">xmm7</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpand</span>   <span style="color:#66d9ef">ymm7</span>, <span style="color:#66d9ef">ymm7</span>, <span style="color:#66d9ef">ymm3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpaddd</span>  <span style="color:#66d9ef">ymm0</span>, <span style="color:#66d9ef">ymm0</span>, <span style="color:#66d9ef">ymm7</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpcmpeqb</span>        <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm8</span>, <span style="color:#66d9ef">xmm1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpxor</span>   <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpmovzxbd</span>       <span style="color:#66d9ef">ymm7</span>, <span style="color:#66d9ef">xmm7</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpand</span>   <span style="color:#66d9ef">ymm7</span>, <span style="color:#66d9ef">ymm7</span>, <span style="color:#66d9ef">ymm3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpaddd</span>  <span style="color:#66d9ef">ymm4</span>, <span style="color:#66d9ef">ymm4</span>, <span style="color:#66d9ef">ymm7</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">vpcmpeqb</span>        <span style="color:#66d9ef">xmm7</span>, <span style="color:#66d9ef">xmm9</span>, <span style="color:#66d9ef">xmm1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">...</span>
</span></span></code></pre></div><p>We can see the <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> registers, and hence LLVM is successfully able to vectorize the <code>allEqual</code> function.</p>
<p>We get the following remarks:</p>
<pre tabindex="0"><code>remark: w.zig:4:15: loop not vectorized: vectorization and interleaving are explicitly disabled, or the loop has already been vectorized
remark: w.zig:4:15: loop not vectorized: vectorization and interleaving are explicitly disabled, or the loop has already been vectorized
</code></pre><p>This remark can occur due to two reasons:</p>
<ul>
<li>
<p>Vectorization has been explicitly disabled using compiler flags such as <code>-fno-vectorize</code> or <code>-fno-unroll-loops</code>.</p>
</li>
<li>
<p>The loops were already vectorized in an earlier optimization phase, so <code>llvm-opt</code> skips redundant attempts.</p>
</li>
</ul>
<p>Since we did not use any such disabling flags, the remark likely results from the second reason. Indicating that the loops have already been successfully vectorized.</p>
<h2 id="results">Results<a hidden class="anchor" aria-hidden="true" href="#results">#</a></h2>
<p>Benchmarking the stdlib implementation against the new implementation that triggers LLVM&rsquo;s auto-vectorizer. The benchmark is performed against 3 scenarios:</p>
<ol>
<li>All elements of the slice match the target.</li>
<li>Only the first element does not match the target.</li>
<li>Only the last element does not match the target.</li>
</ol>
<p><em>1. All elements equal to the target</em></p>
<table>
  <thead>
      <tr>
          <th>Method</th>
          <th>Median (ns)</th>
          <th>Mean(ns)</th>
          <th>Throughput</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>std.mem.allEqual</code></td>
          <td>581131</td>
          <td>580878</td>
          <td>7e9</td>
      </tr>
      <tr>
          <td><code>allEqual_no_early</code></td>
          <td>192468</td>
          <td>192378</td>
          <td>2e10</td>
      </tr>
  </tbody>
</table>
<p><em>2. Only the first element does not match the target.</em></p>
<table>
  <thead>
      <tr>
          <th>Method</th>
          <th>Median(ns)</th>
          <th>Min(ns)</th>
          <th>Throughput</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>std.mem.allEqual</code></td>
          <td>0</td>
          <td>0</td>
          <td>inf</td>
      </tr>
      <tr>
          <td><code>allEqual_no_early</code></td>
          <td>194103</td>
          <td>196067</td>
          <td>2e10</td>
      </tr>
  </tbody>
</table>
<p><em>3. Only the last element does not match the target</em></p>
<table>
  <thead>
      <tr>
          <th>Method</th>
          <th>Median(ns)</th>
          <th>Min(ns)</th>
          <th>Throughput</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>std.mem.allEqual</code></td>
          <td>557238</td>
          <td>557433</td>
          <td>7e9</td>
      </tr>
      <tr>
          <td><code>allEqual_no_early</code></td>
          <td>194800</td>
          <td>194474</td>
          <td>2e10</td>
      </tr>
  </tbody>
</table>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>The auto-vectorized implementation performs well only when all elements match the scalar value or the first mismatch is near the end. If there&rsquo;s a mismatch early on, the early-stopping version is faster. It returns as soon as a mismatch is found, while the vectorized version still scans the entire slice to count all mismatches.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://llvm.org/docs/Vectorizers.html">Auto-Vectorization in LLVM</a></li>
<li><a href="https://cvw.cac.cornell.edu/vector/coding/data-dependencies">Cornell Virtual Workshop - Data Dependencies</a></li>
<li><a href="https://sivukhin.github.io/find-slice-element-position-in-rust.html#Find-element-s-position-in-Rust-9-times-faster">Find element’s position in Rust – 9 times faster! - Nikita Sivukhin</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/zig/">Zig</a></li>
      <li><a href="http://localhost:1313/tags/llvm/">Llvm</a></li>
      <li><a href="http://localhost:1313/tags/simd/">Simd</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">basum</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
